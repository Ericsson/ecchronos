# CLAUDE.md — ecchronos-binary

This file provides guidance to Claude Code (claude.ai/code) when working with the `ecchronos-binary` module.

## Module Overview

`ecchronos-binary` has no Java source code. It is a `pom`-packaged module responsible for three things:
1. **Packaging** — Producing distributable tar.gz/zip archives via Maven Assembly
2. **ecctool CLI** — A Python CLI (`ecctool.py`) and its support library (`ecchronoslib`)
3. **Acceptance testing** — BDD tests (`behave`) and pytest orchestration for the REST API and CLI

**Maven artifact:** `ecchronos-binary-agent` (packaging: `pom`)

## Build Commands

```bash
# Full acceptance test suite (requires Docker)
mvn verify -P python-integration-tests

# Regenerate ecctool documentation (required after CLI changes)
mvn clean install -P generate-ecctool-doc -DskipUTs

# Build distribution archive without tests
mvn install -DskipTests=true
```

## Maven Profiles

| Profile | Activation | Purpose |
|---|---|---|
| `python-integration-tests` | `-Dprecommit.tests` | Runs pytest + behave in Docker |
| `local-python-integration-tests` | `-Dlocalprecommit.tests` | Against local CCM cluster |
| `topology-integration-tests` | manual | Multi-node topology tests |
| `generate-ecctool-doc` | manual | Generates CLI help text/man pages |

## ecctool CLI

### File layout

```
src/bin/ecctool.py          # Main entry point and argument parsing
src/pylib/ecchronoslib/
  rest.py                   # REST API HTTP client classes
  types.py                  # Python data models for REST responses
  table_formatter.py        # Column width calculation and table rendering
  table_printer.py          # Output functions (table and JSON)
```

### Adding a new subcommand

1. Add a new `subparsers.add_parser()` block in `ecctool.py`
2. Add a handler function (e.g. `handle_my_command(args, url, tls_config)`)
3. Add the corresponding REST call in `ecchronoslib/rest.py` (new method on `RepairSchedulerRequest` or a new class)
4. Add a data model in `ecchronoslib/types.py` if the response shape is new
5. Add a printer function in `ecchronoslib/table_printer.py`
6. Add a feature file in `src/test/behave/features/ecctool-my-command.feature`
7. Add step definitions in `src/test/behave/features/steps/ecctool_my_command.py`
8. **Regenerate documentation:** `mvn clean install -P generate-ecctool-doc -DskipUTs`

### CLI output conventions

- Default: pipe-delimited ASCII table via `table_printer.py`
- `--output json`: prints JSON array via `output_json()`
- `--columns col1,col2`: filters table columns; always document available columns in the subcommand's help text

## BDD Acceptance Tests

### Feature file conventions

Feature files live in `src/test/behave/features/`. Step implementations are in `steps/`. Common utilities are in `ecc_step_library/common.py`.

Steps that invoke the CLI use:
```python
from ecc_step_library.common import run_ecctool
output = run_ecctool(context, ["schedules", "--keyspace", "test"])
```

Steps that call the REST API directly use:
```python
from ecchronoslib.rest import RepairSchedulerRequest
result = RepairSchedulerRequest(url).get_schedules()
```

### environment.py

`before_all()` sets up the Cassandra session and ecChronos connection. `after_feature()` truncates test tables and waits for any ongoing repairs to complete. Do not skip `after_feature()` cleanup — leftover repair history breaks subsequent scenarios.

### Python dependencies

Install via:
```bash
pip install behave requests cassandra-driver gevent jsonschema
```

Or use the provided script:
```bash
src/test/bin/install_dependencies.sh
```

## OpenAPI Spec Regeneration

**Any REST API change requires regenerating the spec:**

```bash
mvn verify -P python-integration-tests
```

The generated spec is written to `docs/autogenerated/`. This is enforced by CI — a stale spec will fail the PR check.

## Distribution Assembly

`src/assembly/assembly.xml` defines what goes into the release archive:

| Path | Source |
|---|---|
| `bin/ecc` | `src/bin/ecc.sh` |
| `bin/ecctool` | `src/bin/ecctool.py` |
| `conf/` | `src/resources/*.yml`, `jvm.options`, `logback.xml` |
| `pylib/` | `src/pylib/ecchronoslib/` |
| `lib/` | All runtime JARs from `application-agent` and its transitive deps |

When adding a new configuration file that operators should be able to edit, add it to `src/resources/` and reference it in `assembly.xml`.

## ecc.sh

The shell launcher reads `conf/jvm.options`, builds a classpath from `lib/*.jar`, and passes everything to `java`. If the ecChronos startup command needs to change (e.g. new system property), update `ecc.sh`.

## Code Style

Python files (`ecctool.py`, `ecchronoslib/*.py`) are checked by `pylint` during `python-integration-tests`. The Java/Maven parts follow the Cassandra code style. CheckStyle and PMD are not relevant here (no Java source).
